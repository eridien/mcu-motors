    
  eridien P3 motor controller MCU interface (version 0)
  -----------------------------------------------------
  (should match eridien/mcu-motors respository for MCU version)

  Each MCU is an I2C slave.  Each motor in each MCU has its own I2C address.
  Each motor state is independent (except for error which stops entire mcu).
  There is also an aux output pin.  (fan and buzzer in P3)
  The MCU is coded for a PIC24F16KM202, other 16-bit mcus may work).
  There are 4 bipolar motors called A,B,C,D.
  There are 3 limit switch inputs called 1,2,3.
  Each limit switch can be mapped to a motor at run-time.

  The MCU controller has a specific unusual meaning for a "step".
  It is a 1/8 micro-step which lets distance/speeds fit in 16 bits.

  If using a 20-tooth GT2 pulley, then one step is 1/40 mm.
        steps/rev:        1600
        dist/rev:           40 mm
        dist/step         1/40 mm
        max distance:      800 mm  (max step count: 32,767)

  all speed is in steps/sec
  accel is 0..7: none, 4000, 8000, 20000, 40000, 80000, 200000, 400000 steps/sec/sec
  for 1/40 mm steps: none, 100, 200, 500, 1000, 2000, 5000, 10000 mm/sec/sec
  
  Any I2C write to MCU is a command.  Any read returns a 4-byte status.
  All commands are started immediately even when motor is busy (moving, homing, etc.)
  If needed, the host can check for finished by polling busy-bit in state
  No commands are buffered like G-Code commands
  Commands can be linked to async operations such as clicking on a webpage
  Changed settings take effect immediately even when motor is busy

  -- one-byte commands --
  0001 0000  home       start homing
  0001 0001  test       next read position is end position of homing (test pos)
  0001 0010  stop       soft stop, decelerates, no reset
  0001 0011  stopRst    decelerates and then resets
  0001 0100  reset      hard stop (power down motor with immediate reset)
  0001 0101  motorOn    (power up motor by removing reset)
  0001 0110  fakeHome   set curpos to home pos value setting and turn motor on (fake homing)
  0000 001x  setAux     set aux ouput pin to x (one bit per mcu)

  -- 2-byte move command --
  1aaa aaaa    top 7 bits of target position
    aaaa aaaa  bottom 8 bits

  -- 3-byte speed-move command --
  01ss ssss     set speed setting to value s times 256
    0aaa aaaa   top 7 bits of target position,
    aaaa aaaa   bottom 8 bits

  -- 5-byte accel-speed-move command --  
  0000 1ccc    set acceleration idx setting
    ssss ssss  top 8 bits of speed,
    ssss ssss  bottom 8 bits
    0aaa aaaa  top 7 bits of target position,
    aaaa aaaa  bottom 8 bits

  -- 2-byte jog command  (no bounds checking, does not need to be homed)
  001d ssss    d: direction  
    ssss ssss  s: number of steps

  -- 3-byte to 21-byte settings command --
  write may be short, only setting first entries
  0001 1111  load settings, all are two-byte, big-endian, 16-bit values
    acceleration rate table index 0..7, 0 is off
    default speed
    jerk (start/stop speed and above this speed, acceleration is needed)
    max pos (min pos is always zero))
    homing speed
    homing back-up speed
    home offset distance (final home distance from switch)
    home pos value (set cur pos to this value after homing, usually 0)
    limit switch control for motor A // see below
    limit switch control for motor B
    limit switch control for motor C
    limit switch control for motor D
    backlash distance
    mcuClock;   // period of clock in usecs  (motor 0 applies to entire mcu)

  limit sw control word format for settings command above
  ssss 00dd 0000 000l
    ssss limit switch number, 0: none, 1,2,3
    dd  start dir: 0: rev, 2: limit sw, 3: not limit sw
     l  switch pin active voltage, 0: lo,  1: hi

  limit sw control allows limit switch in middle of travel, not on an end
  start-dir values 2 and 3 allow homing from either side of switch
  ends on dir=1 side of switch no matter what side it started on

  -- 3-byte status read --
  this is the only read format on i2c
  Error code and error bit are cleared on status read, only on addressed motor
    1) vccc eboh  state byte
        v: version (1-bit)
      ccc: error code (see below) (code only set on motor causing error)
        e: error bit              (bit set on all motors in mcu on every error)
        b: busy     (homing, moving, or stopping)
        o: motor on (not in reset)
        h: homed    (motor has been homed since last reset)
    2) aaaa aaaa  signed motor position, top 8 bits (or test pos)
    3) aaaa aaaa  followed by bottom 8 bits

  Error codes for state byte above 
    MOTOR_FAULT_ERROR   0x10  missing, over-heated, or over-current driver chip
    I2C_OVERFLOW_ERROR  0x20  i2c byte received before last taken
    CMD_DATA_ERROR      0x30  command format incorrect
    CMD_NOT_DONE_ERROR  0x40  new command arrived before old cmd finished
    STEP_NOT_DONE_ERROR 0x50  step rate too fast for MCU
    BOUNDS_ERROR        0x60  position < 0 or > max setting when moving
    NOT_HOMED_ERROR     0x70  attempt to do a move when not homed yet

  motor position is stored for testing when homing first closes limit switch
  this allows testing to make sure no steps are missed when doing move/home
  Command 0x11 tells next status read to return this test position
  This status read will have a magic state value of 0x04 (normally impossible)

  position values in commands must be positive, top bit is zero
  position returned in status is signed and may be negative (e.g. when homing)
